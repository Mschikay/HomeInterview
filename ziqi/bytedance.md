# DNS
## 过程
    先查询本地hosts文件
    若无，本地DNS缓存
    若无，本地DNS服务器。   
        路由器接收到请求后，查询路由器DNS缓存
        若无，以外网地址像本地DNS服务器发起DNS查询请求
        如果自己不是权威DNS，切无缓存，进行DNS递归查询，将请求发送给根域名服务器
            根域名服务器 接收到请求后，将 顶级域名服务器 (.com) IP 发送给 其他 DNS 服务器
            其他 DNS 服务器 根据 IP 将 DNS 查询请求发送给 顶级域名服务器
            顶级域名服务器 接收到请求后，将 二级域名服务器 (jianshu.com) IP 发送给 其他 DNS 服务器
            其他域名服务器 根据 IP 将 DNS 查询请求发送给 二级域名服务器
            二级域名服务器 接收到请求后，发现自己是权威 DNS 服务器，于是将 www.jianshu.com 映射的 IP 120.132.92.21 发送给 其他域名服务器
            其他域名服务器 接收到解析结果后，将 120.132.92.21 逐层返回传递下去，最终直至 192.168.110.252
            192.168.110.252 接收到 www.jianshu.com 解析结果 120.132.92.21 ，根据 IP 与 www.jianshu.com 建立 TCP 连接，然后发起 HTTP 请求主页内容


DNS 服务器返回的不一定是 IP ，在 DNS 请求中域名为别名时，则 DNS 服务器会返回其 A 记录；因为 A 记录与 IP 映射，于是主机又向 DNS 服务器 发起 A记录 DNS 请求

## DNS循环
当权威 DNS 发现一个域名映射多个 IP 时，会使用 IP 轮询的方式来将 IP 平均分配给多个 DNS 请求，从而达到负载均衡的效果

## CDN
如果有一台服务器宕机了，DNS 不能及时了解到该情况把该服务器的 IP 分配出去，便会造成无法访问；因此，在权威 DNS 和 服务器之间加上一个 CDN 层就显得很必要了；CDN能够同步服务器运行情况，然后根据该情况及时适当调整调度策略，从而使得负载均衡能力大大提高；

# HTTPDNS
运营商的LocalDNS可能会造成不可访问（域名解析错误、过时、只有http的80端口而无法访问https和其他端口）、网络时延等等

HttpDNS能有效地避免由于移动互联网用户所使用的LocalDNS异常导致的无法访问到您预期的最优接入点，最终导致用户访问您的业务出现异常。

客户端直接访问HttpDNS接口，获取域名的最优IP。（基于容灾考虑，建议保留使用运营商LocalDNS解析域名的方式作为备选。）客户端获取到业务IP后，通过在header中指定host字段，向HttpDNS返回的IP发送标准的Http请求即可。

[腾讯云HttpDNS产品]（https://cloud.tencent.com/document/product/379/3519#httpdns.E5.AE.9E.E7.8E.B0.E7.9A.84.E5.8E.9F.E7.90.86.3F）

## 优势
* 根治域名解析异常
* 调度精准
* 实现成本低

    仅需要对客户端接入层做少量改造，无需用户手机进行root或越狱。
    由于Http协议请求构造非常简单，兼容各版本的移动操作系统更不成问题
* 扩展性强
    
    业务可将自有调度逻辑与HttpDNS返回结果结合，实现更精细化的流量调度。比如指定版本的客户端连接请求的IP地址，指定网络类型的用户连接指定的IP地址等。

# 有哪些方法能加快网络连接速度
## 减少调用
任何时候通过一个 socket 来读写数据时，都是在使用一个系统调用（system call）。

系统调用不仅仅是在应用程序和内核中进行操作的，而且还要经过应用程序和内核中的很多层次。这个过程耗费的资源很高，因此调用次数越多，通过这个调用链进行的工作所需要的时间就越长，应用程序的性能也就越低。

在将数据写入一个 socket 时，尽量一次写入所有的数据，而不是执行多次写数据的操作。对于读操作来说，最好传入可以支持的最大缓冲区，因为如果没有足够多的数据，内核也会试图填充 整个缓冲区（另外还需要保持 TCP 的通告窗口为打开状态）。这样就可以最小化调用的次数，并可以实现更好的整体性能。
## 禁用Nagle算法
Nagle 算法满足一种需求。由于这种算法对数据进行合并，试图构成一个完整的 TCP 报文段，因此它会引入一些延时。但是这种算法可以最小化在线路上发送的报文的数量，因此可以最小化网络拥塞的问题。

[linux socket 优化,提升网络速度](http://www.voidcn.com/article/p-pvdlrczh-xh.html)

## QoS
QoS是最近交换机和软件厂商等倡导的一项技术，QoS能够保证企业关键性的服务稳定，通过在交换机中保留一定的带宽给关键服务数据包，关键服务的性能能够得到保证。但是，QoS的开启意味着20%以上的普通网络通讯速度流失，所以对于企业网和网上业务密集的网络，开启QoS，否则，关掉它。 

## 第三层交换机
VLAN是把物理上通过同等方式的连接虚拟成为多个不同的子网。VLAN最大的功能就是防止广播风暴。一般来说，如果一个网络的广播包占到所有的通讯包的30%以上，网络性能就显著下降。

工作在网络层

[为什么三层交换机无法代替路由器](https://www.zhihu.com/question/20843778)

## 路由和第二层交换机的不同

* 工作层次不同 

    最初的的交换机是工作在**数据链路层**，而路由器一开始就设计工作在网络层。由于交换机工作在数据链路层，所以它的工作原理比较简单，而路由器工作在网络层，可以得到更多的协议信息，路由器可以做出更加智能的转发决策。 

* 数据转发所依据的对象不同 
    
    交换机是利用物理地址或者说**MAC**地址来确定转发数据的目的地址。而路由器则是利用IP地址来确定数据转发的地址。IP地址是在软件中实现的，描述的是设备所在的网络。MAC地址通常是硬件自带的，由网卡生产商来分配的，而且已经固化到了网卡中去，一般来说是不可更改的。而IP地址则通常由网络管理员或系统自动分配。 

* 传统的交换机只能分割冲突域，不能分割广播域；而路由器可以分割广播域 
    
    由交换机连接的网段仍属于**同一个广播域**，广播数据包会在交换机连接的所有网段上传播，在某些情况下会导致通信拥挤和安全漏洞。连接到路由器上的网段会被分配成不同的广播域，广播数据不会穿过路由器。虽然第三层以上交换机具有VLAN功能，也可以分割广播域，但是各子广播域之间是不能通信交流的，它们之间的交流仍然需要路由器。 

* 路由器提供了防火墙的服务 

    路由器仅仅转发特定地址的数据包，不传送不支持路由协议的数据包和未知目标网络的数据包，从而可以防止广播风暴。

## 优化一个正常的网络请求

DNS 解析，请求DNS服务器，获取域名对应的 IP 地址；
与服务端建立连接，包括 

tcp 三次握手，安全协议同步流程；

连接建立完成，发送和接收数据，解码数据。

这里有明显的三个优化点：

直接使用 IP 地址，去除 DNS 解析步骤；（HTTPDNS）

不要每次请求都重新建立连接，复用连接或一直使用同一条连接(长连接)；多路复用：HTTP2 的多路复用机制一样是复用连接，但它复用的这条连接支持同时处理多条请求，所有请求都可以并发在这条连接上进行，也就解决了并发请求需要建立多条连接带来的问题。

压缩数据，减小传输的数据大小。
[http://www.52im.net/thread-1413-1-1.html]（http://www.52im.net/thread-1413-1-1.html）

# 如何维持长连接保活

## TCP层Keep Alive（客户端/服务器端发送）

TCP协议实现中，是有保活机制的，也就是TCP的KeepAlive机制（此机制并不是TCP协议规范中的内容，由操作系统去实现），KeepAlive机制开启后，在一定时间内（一般时间为7200s，参数tcp_keepalive_time）在链路上没有数据传送的情况下，TCP层将发送相应的KeepAlive探针以确定连接可用性，探测失败后重试10（参数tcp_keepalive_probes）次，每次间隔时间75s（参数tcp_keepalive_intvl），所有探测失败后，才认为当前连接已经不可用。这些参数是机器级别，可以调整。

## 应用层自己实现的心跳包
KeepAlive的保活机制只在链路空闲的情况下才会起到作用，假如此时有数据发送，且物理链路已经不通，操作系统这边的链路状态还是ESTABLISHED，这时会发生什么？自然会走TCP重传机制，要知道默认的TCP超时重传，指数退避算法也是一个相当长的过程。因此，一个可靠的系统，长连接的保活肯定是要依赖应用层的心跳来保证的。


# 如何发送心跳包
1. 客户端每隔一个时间间隔发生一个探测包给服务器
2.  客户端发包时启动一个超时定时器
3.  服务器端接收到检测包，应该回应一个包
4.  如果客户机收到服务器的应答包，则说明服务器正常，删除超时定时器
5. 如果客户端的超时定时器超时，依然没有收到应答包，则说明服务器挂了

# 栈和堆有什么区别
栈在堆上面，是向低内存方向增长的。如果栈不断地增加，很可能会与.bss段发生碰撞，这是不堪设想的，系统会发出错误并终止程序。

栈应该被看成一个短期存储数据的地方，存在在栈中的数据项没有名字，只是按照后进先出来操作罢了。栈经常可以用来在寄存器紧张的情况下，**临时**存储一些数据，并且十分安全。当寄存器空闲后，我们可以从栈中弹出该数据，供寄存器使用。这种临时存放数据的特性，使得它经常用来存储局部变量，函数参数，上下文环境等。

栈有一个指向栈顶的指针寄存器ESP，会自动增长和释放；而堆需要程序员手动申请和释放，可以分配更大的空间，但开销也会更多

[内存中的堆和栈到底是什么](https://www.jianshu.com/p/52b5a1879aa1)

