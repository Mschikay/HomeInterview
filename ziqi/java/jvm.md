
# JVM
## 特点
平台（不同操作系统）无关
## 功能
编译后的 Java 程序指令并不直接在硬件系统的 CPU 上执行。Java语言编译程序只需要生成在JVM上运行的目标字节码（.class）,就可以在多种平台上不加修改地运行。Java 虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。因此实现java平台无关性。

#### Class文件
Class文件由Java编译器生成，我们创建的.Java文件在经过编译器后，会变成.Class的文件，这样才能被JVM所识别并运行。

## 启动过程
java.exe choose a JRE

load JVM

初始化JVM，获得本地调用接口

运行JAVA

## 组成
JVM = 类加载器 classloader + 执行引擎 execution engine + 运行时数据区域 runtime data area

[掘金](https://segmentfault.com/a/1190000002579346)

#### PC Register pc程序计数器
当前线程所执行的字节码的行号指示器

线程私有，以便完成上下文切换（？）

#### jvm stack 虚拟机栈
线程私有，生命周期和线程一样

虚拟机栈描述的是Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

#### native method stack 本地方法栈
类似虚拟机栈

    虚拟机栈 =》 执行java方法
    本地方法栈 =》 本地方法

#### Java heap 堆
线程共享，jvm启动时创建，被自动管理内存系统（Automatic Storage Management System，也即是常说的 “Garbage Collector（垃圾回收器）”）所管理

    线程共享，因此对象内存的分配均需要进行加锁，这也是new开销比较大的原因
    Sun Hotspot JVM为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间，这块空间又称为TLAB
    TLAB仅作用于新生代的Eden Space，因此在编写Java程序时，通常多个小的对象比大的对象分配起来更加高效
存储对象实例以及数组值的区域，可以认为Java中所有通过new创建的对象的内存都在此分配。

#### 方法区 method area
线程共享，jvm启动时创建，在一定条件下也会被GC——这块区域对应Permanent Generation 持久代

用于存储每一个类的结构信息

constant pool 常量池从其中分配，存放固定的常量信息、方法和域的引用

# 垃圾回收
## 分代
* 新生代 Young Generation

    1. Eden Space 任何新进入运行时数据区域的实例都会存放在此
    2. S0 Suvivor Space 存在时间较长，经过垃圾回收没有被清除的实例，就从Eden 搬到了S0
    3. S1 Survivor Space 同理，存在时间更长的实例，就从S0 搬到了S1

* 旧生代 Old Generation/tenured
        
    存在时间更长的实例，对象多次回收没被清除，就从S1 搬到了tenured
* Perm 存放运行时数据区的方法区
## 过程
Java 不同的世代使用不同的 GC 算法。

Minor collection：

    对于新生代（Eden，Survivor）利用 semi-space 做复制收集（垃圾占的比例多了，将可引用的对象复制到新空间），并将原本 Survivor 内经过多次垃圾收集仍然存活的对象移动到 Tenured。

Major collection 
    
    Minor collection，Tenured 世代则进行标记压缩收集。（Tenured占的比例不多了）

## 垃圾回收算法
#### 标记清除 / 标记压缩

缺点：
    
    在分配了大量对象，并且其中只有一小部分存活的情况下，所消耗的时间会大大超过必要的值，这是因为在清除阶段还需要对大量死亡对象进行扫描。

#### 复制收集
缺点：
    
    将对象复制一份所需要的开销则比较大，因此在“存活”对象比例较高的情况下，反而会比较不利。

优点：

    局部性（Lo-cality）。在复制收集过程中，会按照对象被引用的顺序将对象复制到新空间中。于是，关系较近的对象被放在距离较近的内存空间中的可能性会提高，这被称为局部性。局部性高的情况下，内存缓存会更容易有效运作，程序的运行性能也能够得到提高。

#### 引用计数
Python Perl的GC是这个

缺点：
    
    1. 无法释放循环引用对象
    2. 必须在引用发生增减时对引用计数做出正确的增减，而如果漏掉了某个增减的话，就会引发很难找到原因的内存错误。引用数忘了增加的话，会对不恰当的对象进行释放；而引用数忘了减少的话，对象会一直残留在内存中，从而导致内存泄漏。
    3. 引用计数管理并不适合并行处理。如果多个线程同时对引用计数进行增减的话，引用计数的值就可能会产生不一致的问题（结果则会导致内存错误）。为了避免这种情况的发生，对引用计数的操作必须采用独占的方式来进行。如果引用操作频繁发生，每次都要使用加锁等并发控制机制的话，其开销也是不可小觑的。

优点：实现“简单”